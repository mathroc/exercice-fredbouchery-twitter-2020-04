#!/bin/env php
<?php

array_shift($argv);

$filePath = array_shift($argv);

if (!file_exists($filePath)) {
    echo "$filePath does not exists", PHP_EOL;
    exit(1);
}

if (!is_readable($filePath)) {
    echo "$filePath is not a readable file", PHP_EOL;
    exit(1);
}

$fields = null;
$aggregate = null;
$desc = null;
$pretty = false;

while (($arg = array_shift($argv)) !== null) {
    if ($arg === "--pretty") {
        $pretty = true;
    } else if (in_array($arg, ["--fields", "--aggregate", "--desc"])) {
        $value = array_shift($argv);

        if ($value === null) {
            echo "Missing value for $arg parameter", PHP_EOL;
            exit(1);
        }

        ${substr($arg, 2)} = $value;
    } else {
        echo "Unknown $arg parameter", PHP_EOL;
        exit(1);
    }
}

linesToJson(lines($filePath, $fields, $aggregate), $pretty, $aggregate !== null);

function lines(string $filePath, ?string $fields, ?string $aggregate): Iterator
{
    $fields = fields($fields);

    $file = new SplFileObject($filePath);

    $file->setCsvControl(guessDelimiter($file->current()));
    $file->setFlags(SplFileObject::READ_CSV | SplFileObject::SKIP_EMPTY | SplFileObject::READ_AHEAD);
    $file->rewind();

    $header = $file->current();

    $keepAggregateField = false;

    if ($aggregate !== null && is_array($fields)) {
        if (in_array($aggregate, $fields)) {
            $keepAggregateField = true;
        } else {
            $fields[] = $aggregate;
        }
    }

    $fields ??= $header;

    $diff = array_diff($fields, $header);

    if (!empty($diff)) {
        echo "Invalid fields: ", implode(", ", $diff), PHP_EOL;
        echo "Should be in: ", implode(", ", $header), PHP_EOL;
        exit(1);
    }

    $mapping = [];
    $headerKeys = array_flip($header);

    foreach (array_intersect($fields, $header) as $field) {
        $mapping[$field] = $headerKeys[$field];
    }

    $transform = fn (array $values): array => array_map(fn ($key) => $values[$key], $mapping);

    $lines = iterate($file, $transform);

    if ($aggregate === null) {
        return $lines;
    }

    if (!isset($headerKeys[$aggregate])) {
        echo "Invalid aggregate: $aggregate", PHP_EOL;
        echo "Should be one of: ", implode(", ", $header), PHP_EOL;
        exit(1);
    }

    $aggregate = function (Iterator $lines) use ($aggregate, $keepAggregateField): Iterator {
        $data = [];

        foreach ($lines as $line) {
            $key = $line[$aggregate];

            if (!array_key_exists($key, $data)) {
                $data[$key] = [];
            }

            if (!$keepAggregateField) {
                unset($line[$aggregate]);
            }

            $data[$key][] = $line;
        }

        return new ArrayIterator($data);
    };

    return $aggregate($lines);
}

function iterate(SplFileObject $file, callable $transform): Iterator
{
    for($file->next(); !$file->eof(); $file->next()) {
        yield $transform($file->current());
    }
}

function linesToJson(Iterator $lines, bool $pretty, bool $object): void {
    $flags = $pretty ? JSON_PRETTY_PRINT : 0;

    if ($object) {
        echo json_encode(iterator_to_array($lines), $flags);
        return;
    }

    $comma = "," . ($pretty ? " " : "");

    $line = $lines->current();
    echo "[", json_encode($line, $flags);

    for ($lines->next(); $lines->valid(); $lines->next()) {
        echo $comma, json_encode($lines->current(), $flags);
    }

    echo "]";
}

function fields(?string $fields): ?array {
    return $fields === null ? null : array_map("trim", explode(guessDelimiter($fields), $fields));
}

function guessDelimiter(string $header): string {
    return ";";
}
